{"version":3,"file":"main.min.js","mappings":"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","sources":["webpack://image-stylization-threading/./src/ts/helpers.ts","webpack://image-stylization-threading/./src/ts/main.ts","webpack://image-stylization-threading/./src/ts/parameters.ts","webpack://image-stylization-threading/./src/ts/plotter/compositing.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-base.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-canvas-2d.ts","webpack://image-stylization-threading/./src/ts/plotter/plotter-svg.ts","webpack://image-stylization-threading/./src/ts/plotter/xml-writer.ts","webpack://image-stylization-threading/./src/ts/threading/thread-computer.ts","webpack://image-stylization-threading/./src/ts/threading/thread-plotter.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-base.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-monochrome.ts","webpack://image-stylization-threading/./src/ts/threading/thread/thread-red-green-blue.ts","webpack://image-stylization-threading/./src/ts/threading/transformation.ts","webpack://image-stylization-threading/webpack/bootstrap","webpack://image-stylization-threading/webpack/startup"],"sourcesContent":["function downloadTextFile(content: string, filename: string): void {\r\n    const fileType = \"text/plain\";\r\n\r\n    const blob = new Blob([content], { type: fileType });\r\n\r\n    if (typeof window.navigator !== \"undefined\" && typeof (window.navigator as any).msSaveBlob !== \"undefined\") { // for IE\r\n        (window.navigator as any).msSaveBlob(blob, filename);\r\n    } else {\r\n        const objectUrl = URL.createObjectURL(blob);\r\n\r\n        const linkElement = document.createElement('a');\r\n        linkElement.download = filename;\r\n        linkElement.href = objectUrl;\r\n        linkElement.dataset.downloadurl = `${fileType}:${linkElement.download}:${linkElement.href}`;\r\n        linkElement.style.display = \"none\";\r\n        document.body.appendChild(linkElement);\r\n        linkElement.click();\r\n        document.body.removeChild(linkElement);\r\n\r\n        // don't forget to free the objectURL after a few seconds\r\n        setTimeout(() => {\r\n            URL.revokeObjectURL(objectUrl);\r\n        }, 5000);\r\n    }\r\n}\r\n\r\nfunction getQueryStringValue(name: string): string | null {\r\n    const url = window.location.href;\r\n    const queryStringStart = url.indexOf(\"?\");\r\n    if (queryStringStart >= 0) {\r\n        const queryString = url.substring(queryStringStart + 1);\r\n        if (queryString.length > 0) {\r\n            const parameters = queryString.split(\"&\");\r\n            for (const parameter of parameters) {\r\n                const keyValue = parameter.split(\"=\");\r\n                if (keyValue.length === 2) {\r\n                    const decodedKey = decodeURIComponent(keyValue[0]);\r\n                    if (decodedKey === name) {\r\n                        return decodeURIComponent(keyValue[1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction declareArrayIncludesPolyfill(): void {\r\n    if (typeof Array.prototype.includes !== \"function\") {\r\n        console.log(\"Declaring Array.includes polyfill...\");\r\n        Object.defineProperty(Array.prototype, \"includes\", {\r\n            value<T>(this: T[], element: any): boolean {\r\n                return this.indexOf(element) >= 0;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction declareStringRepeatPolyfill(): void {\r\n    if (typeof String.prototype.repeat !== \"function\") {\r\n        console.log(\"Declaring String.repeat polyfill...\");\r\n        Object.defineProperty(String.prototype, \"repeat\", {\r\n            value(this: string, count: number): string {\r\n                if (count < 0 || count === Infinity) {\r\n                    throw new RangeError();\r\n                }\r\n\r\n                let result = \"\";\r\n                for (let i = 0; i < count; i++) {\r\n                    result += this;\r\n                }\r\n                return result;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nfunction declarePolyfills(): void {\r\n    declareArrayIncludesPolyfill();\r\n    declareStringRepeatPolyfill();\r\n}\r\n\r\nexport {\r\n    declarePolyfills,\r\n    downloadTextFile,\r\n    getQueryStringValue,\r\n};\r\n","import * as Helpers from \"./helpers\";\r\n\r\nimport { Parameters } from \"./parameters\";\r\n\r\nimport { PlotterCanvas2D } from \"./plotter/plotter-canvas-2d\";\r\nimport { PlotterSVG } from \"./plotter/plotter-svg\";\r\n\r\nimport { ThreadComputer } from \"./threading/thread-computer\";\r\nimport { ThreadPlotter } from \"./threading/thread-plotter\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nfunction main(): void {\r\n    const MAX_COMPUTING_TIME_PER_FRAME = 20; // ms\r\n    const canvasPlotter = new PlotterCanvas2D();\r\n    let threadPlotter: ThreadPlotter = null;\r\n    let threadComputer: ThreadComputer = null;\r\n    let needToReset = true;\r\n\r\n    Parameters.addRedrawObserver(() => { threadPlotter?.reset(); });\r\n    Parameters.addResetObserver(() => { needToReset = true; });\r\n\r\n    function mainLoop(): void {\r\n        if (needToReset) {\r\n            threadComputer.reset(Parameters.linesOpacity, Parameters.linesThickness);\r\n            threadPlotter.reset()\r\n            needToReset = false;\r\n        }\r\n\r\n        const computedSomething = threadComputer.computeNextSegments(MAX_COMPUTING_TIME_PER_FRAME);\r\n\r\n        if (computedSomething && Parameters.showIndicators) {\r\n            threadComputer.updateIndicators(Page.Canvas.setIndicatorText);\r\n        }\r\n\r\n        threadPlotter.plot();\r\n\r\n        if (Parameters.debug) {\r\n            threadComputer.drawDebugView(canvasPlotter.context);\r\n        }\r\n\r\n        requestAnimationFrame(mainLoop);\r\n    }\r\n\r\n    function updateBlur(blur: number): void {\r\n        canvasPlotter.blur = blur;\r\n    }\r\n    Parameters.addBlurChangeObserver(updateBlur);\r\n    updateBlur(Parameters.blur);\r\n\r\n    function onNewImage(image: HTMLImageElement): void {\r\n        Page.Canvas.showLoader(false);\r\n        threadComputer = new ThreadComputer(image);\r\n        threadPlotter = new ThreadPlotter(canvasPlotter, threadComputer);\r\n        needToReset = true;\r\n    }\r\n    Parameters.addFileUploadObserver(onNewImage);\r\n\r\n    Page.Canvas.showLoader(true);\r\n    const defaultImage = new Image();\r\n    defaultImage.addEventListener(\"load\", () => {\r\n        onNewImage(defaultImage);\r\n        requestAnimationFrame(mainLoop);\r\n    });\r\n    defaultImage.src = \"./resources/cat.jpg\";\r\n\r\n    Parameters.addDownloadObserver(() => {\r\n        const svgPlotter = new PlotterSVG();\r\n        const plotter = new ThreadPlotter(svgPlotter, threadComputer);\r\n        plotter.plot();\r\n        const svgString = svgPlotter.export();\r\n        const filename = \"image-as-threading.svg\";\r\n        Helpers.downloadTextFile(svgString, filename);\r\n    });\r\n\r\n    Parameters.addDownloadInstructionsObserver(() => {\r\n        const text = threadComputer.instructions;\r\n        const filename = \"image-as-threading_instructions.txt\";\r\n        Helpers.downloadTextFile(text, filename);\r\n    });\r\n}\r\n\r\nHelpers.declarePolyfills();\r\nmain();\r\n","import * as Helpers from \"./helpers\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nconst controlId = {\r\n    UPLOAD_INPUT_IMAGE: \"input-image-upload-button\",\r\n    SHAPE: \"shape-tabs-id\",\r\n    PEGS_COUNT: \"pegs-range-id\",\r\n    NB_LINES: \"lines-range-id\",\r\n    QUALITY: \"quality-tabs-id\",\r\n    MODE: \"thread-mode-tabs-id\",\r\n    LINES_OPACITY: \"opacity-range-id\",\r\n    LINES_THICKNESS: \"thickness-range-id\",\r\n    DISPLAY_PEGS: \"display-pegs-checkbox-id\",\r\n    INVERT_COLORS: \"invert-colors-checkbox-id\",\r\n    SHOW_INDICATORS: \"show-indicators-checkbox-id\",\r\n    BLUR: \"blur-range-id\",\r\n    DOWNLOAD: \"result-download-id\",\r\n    DOWNLOAD_INSTRUCTIONS: \"instructions-download-id\",\r\n};\r\n\r\nenum EShape {\r\n    RECTANGLE = \"0\",\r\n    ELLIPSIS = \"1\",\r\n}\r\n\r\nenum EMode {\r\n    MONOCHROME = \"0\",\r\n    COLORS = \"1\",\r\n}\r\n\r\ntype Observer = () => unknown;\r\nconst redrawObservers: Observer[] = [];\r\nfunction triggerRedraw(): void {\r\n    for (const observer of redrawObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nconst resetObservers: Observer[] = [];\r\nfunction triggerReset(): void {\r\n    for (const observer of resetObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nPage.Tabs.addObserver(controlId.SHAPE, triggerReset);\r\nPage.Range.addLazyObserver(controlId.PEGS_COUNT, triggerReset);\r\nPage.Tabs.addObserver(controlId.QUALITY, triggerReset);\r\nPage.Tabs.addObserver(controlId.MODE, triggerReset);\r\nPage.Range.addLazyObserver(controlId.LINES_OPACITY, triggerReset);\r\nPage.Range.addLazyObserver(controlId.LINES_THICKNESS, triggerReset);\r\nPage.Checkbox.addObserver(controlId.DISPLAY_PEGS, triggerRedraw);\r\nPage.Checkbox.addObserver(controlId.INVERT_COLORS, triggerReset);\r\nPage.Canvas.Observers.canvasResize.push(triggerRedraw);\r\n\r\nconst isInDebug = Helpers.getQueryStringValue(\"debug\") === \"1\";\r\n\r\nPage.Canvas.setIndicatorVisibility(\"error-average\", isInDebug);\r\nPage.Canvas.setIndicatorVisibility(\"error-mean-square\", isInDebug);\r\nPage.Canvas.setIndicatorVisibility(\"error-variance\", isInDebug);\r\n\r\nfunction updateIndicatorsVisibility(): void {\r\n    const shouldBeVisible = Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);\r\n    Page.Canvas.setIndicatorsVisibility(shouldBeVisible);\r\n}\r\nPage.Checkbox.addObserver(controlId.SHOW_INDICATORS, updateIndicatorsVisibility);\r\nupdateIndicatorsVisibility();\r\n\r\nabstract class Parameters {\r\n    public static addFileUploadObserver(callback: (image: HTMLImageElement) => unknown): void {\r\n        Page.FileControl.addUploadObserver(controlId.UPLOAD_INPUT_IMAGE, (filesList: FileList) => {\r\n            if (filesList.length === 1) {\r\n                Page.Canvas.showLoader(true);\r\n                const reader = new FileReader();\r\n                reader.onload = () => {\r\n                    const image = new Image();\r\n                    image.addEventListener(\"load\", () => {\r\n                        callback(image);\r\n                    })\r\n                    image.src = reader.result as string;\r\n                };\r\n                reader.readAsDataURL(filesList[0]);\r\n            }\r\n        });\r\n    }\r\n\r\n    public static get debug(): boolean {\r\n        return isInDebug;\r\n    }\r\n\r\n    public static get shape(): EShape {\r\n        return Page.Tabs.getValues(controlId.SHAPE)[0] as EShape;\r\n    }\r\n\r\n    public static get pegsCount(): number {\r\n        return Page.Range.getValue(controlId.PEGS_COUNT);\r\n    }\r\n\r\n    public static get quality(): number {\r\n        return +Page.Tabs.getValues(controlId.QUALITY)[0];\r\n    }\r\n\r\n    public static get mode(): EMode {\r\n        return Page.Tabs.getValues(controlId.MODE)[0] as EMode;\r\n    }\r\n\r\n    public static get nbLines(): number {\r\n        return Page.Range.getValue(controlId.NB_LINES);\r\n    }\r\n\r\n    public static get linesOpacity(): number {\r\n        const raw = Page.Range.getValue(controlId.LINES_OPACITY);\r\n        return Math.pow(2, raw - 7); // 2^(raw+2) / 256\r\n    }\r\n\r\n    public static get linesThickness(): number {\r\n        return Page.Range.getValue(controlId.LINES_THICKNESS);\r\n    }\r\n\r\n    public static get displayPegs(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.DISPLAY_PEGS);\r\n    }\r\n\r\n    public static get invertColors(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.INVERT_COLORS);\r\n    }\r\n\r\n    public static get showIndicators(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.SHOW_INDICATORS);\r\n    }\r\n\r\n    public static addRedrawObserver(callback: Observer): void {\r\n        redrawObservers.push(callback);\r\n    }\r\n\r\n    public static addResetObserver(callback: Observer): void {\r\n        resetObservers.push(callback);\r\n    }\r\n\r\n    public static get blur(): number {\r\n        return Page.Range.getValue(controlId.BLUR);\r\n    }\r\n    public static addBlurChangeObserver(callback: (newBlur: number) => unknown): void {\r\n        Page.Range.addObserver(controlId.BLUR, callback);\r\n    }\r\n\r\n    public static addDownloadObserver(callback: () => unknown): void {\r\n        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD, callback);\r\n    }\r\n\r\n    public static addDownloadInstructionsObserver(callback: () => unknown): void {\r\n        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD_INSTRUCTIONS, callback);\r\n    }\r\n}\r\n\r\nfunction updateDownloadInstructionsVisibility(): void {\r\n    const isMonochrome = (Parameters.mode === EMode.MONOCHROME);\r\n    const isBlackOnWhite = !Parameters.invertColors;\r\n    Page.Controls.setVisibility(controlId.DOWNLOAD_INSTRUCTIONS, isMonochrome && isBlackOnWhite);\r\n}\r\nPage.Tabs.addObserver(controlId.MODE, updateDownloadInstructionsVisibility);\r\nPage.Checkbox.addObserver(controlId.INVERT_COLORS, updateDownloadInstructionsVisibility);\r\nupdateDownloadInstructionsVisibility();\r\n\r\nexport {\r\n    Parameters,\r\n    EMode,\r\n    EShape,\r\n};\r\n","import \"../page-interface-generated\";\r\n\r\nenum ECompositingOperation {\r\n    DARKEN,\r\n    LIGHTEN,\r\n}\r\n\r\nenum EColor {\r\n    MONOCHROME,\r\n    RED,\r\n    GREEN,\r\n    BLUE,\r\n}\r\n\r\ninterface IColor {\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n}\r\n\r\nlet supportsAdvancedCompositing = true;\r\nfunction useAdvancedCompositing(): boolean {\r\n    return supportsAdvancedCompositing;\r\n}\r\n\r\nfunction computeRawColor(color: EColor): IColor {\r\n    if (color === EColor.MONOCHROME) {\r\n        return { r: 1, g: 1, b: 1 };\r\n    }\r\n\r\n    const result: IColor = {\r\n        r: (color === EColor.RED) ? 1 : 0,\r\n        g: (color === EColor.GREEN) ? 1 : 0,\r\n        b: (color === EColor.BLUE) ? 1 : 0,\r\n    };\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * @param opacity in [0, 1]\r\n */\r\nfunction applyCanvasCompositing(context: CanvasRenderingContext2D, color: EColor, opacity: number, operation: ECompositingOperation): void {\r\n    const rawRGB = computeRawColor(color);\r\n\r\n    if (supportsAdvancedCompositing) {\r\n        const targetOperation = (operation === ECompositingOperation.LIGHTEN) ? \"lighter\" : \"difference\";\r\n        context.globalCompositeOperation = targetOperation;\r\n        if (context.globalCompositeOperation === targetOperation) {\r\n            const value = Math.ceil(255 * opacity);\r\n            context.strokeStyle = `rgb(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value})`;\r\n            return; // success\r\n        } else {\r\n            supportsAdvancedCompositing = false;\r\n            Page.Demopage.setErrorMessage(\"advanced-compositing-not-supported\", `Your browser does not support canvas2D compositing '${targetOperation}'. The project will not run as expected.`);\r\n        }\r\n    }\r\n\r\n    // basic compositing\r\n    {\r\n        resetCanvasCompositing(context);\r\n        if (operation === ECompositingOperation.DARKEN) {\r\n            rawRGB.r = 1 - rawRGB.r;\r\n            rawRGB.g = 1 - rawRGB.g;\r\n            rawRGB.b = 1 - rawRGB.b;\r\n        }\r\n        context.strokeStyle = `rgba(${rawRGB.r * 255}, ${rawRGB.g * 255}, ${rawRGB.b * 255}, ${opacity})`;\r\n    }\r\n}\r\n\r\nfunction resetCanvasCompositing(context: CanvasRenderingContext2D): void {\r\n    context.globalCompositeOperation = \"source-over\";\r\n}\r\n\r\nexport {\r\n    EColor,\r\n    ECompositingOperation,\r\n    applyCanvasCompositing,\r\n    computeRawColor,\r\n    resetCanvasCompositing,\r\n    useAdvancedCompositing,\r\n};\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { EColor, ECompositingOperation } from \"./compositing\";\r\n\r\ninterface IPlotterInfo {\r\n    backgroundColor: string;\r\n    blur: number;\r\n}\r\n\r\ninterface IImageFitting {\r\n    sizeInPlotter: ISize;\r\n    imageRelativeToCanvasPixel: (relativeCoords: IPoint) => IPoint;\r\n};\r\n\r\nabstract class PlotterBase {\r\n    public abstract resize(): void;\r\n    public abstract initialize(infos: IPlotterInfo): void;\r\n    public abstract finalize(): void;\r\n\r\n    public abstract drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void;\r\n    public abstract drawPoints(points: IPoint[], color: string, diameter: number): void;\r\n\r\n    public abstract get size(): ISize;\r\n\r\n    public drawBrokenLine(points: IPoint[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        const lines: ILine[] = [];\r\n\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            lines.push({ from: points[i], to: points[i + 1] });\r\n        }\r\n        this.drawLines(lines, color, opacity, operation, thickness);\r\n    }\r\n}\r\n\r\nexport { PlotterBase, IImageFitting, IPlotterInfo, ISize }\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { applyCanvasCompositing, EColor, ECompositingOperation, resetCanvasCompositing } from \"./compositing\";\r\nimport { IPlotterInfo, PlotterBase } from \"./plotter-base\";\r\n\r\nimport \"../page-interface-generated\";\r\n\r\nclass PlotterCanvas2D extends PlotterBase {\r\n    private readonly canvas: HTMLCanvasElement;\r\n    public readonly context: CanvasRenderingContext2D;\r\n    private readonly cssPixel: number;\r\n\r\n    public constructor() {\r\n        super();\r\n\r\n        this.canvas = Page.Canvas.getCanvas();\r\n        this.context = this.canvas.getContext(\"2d\", { alpha: false });\r\n        this.cssPixel = window.devicePixelRatio ?? 1;\r\n    }\r\n\r\n    public resize(): void {\r\n        const actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);\r\n        const actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);\r\n\r\n        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {\r\n            this.canvas.width = actualWidth;\r\n            this.canvas.height = actualHeight;\r\n        }\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.context.fillStyle = infos.backgroundColor;\r\n        this.context.lineJoin = \"round\";\r\n        resetCanvasCompositing(this.context);\r\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public finalize(): void { }\r\n\r\n    public set blur(value: number) {\r\n        if (value === 0) {\r\n            this.canvas.style.filter = \"\";\r\n        } else {\r\n            this.canvas.style.filter = `blur(${value}px)`; // simple blur supported everywhere but with artifacts on the edges\r\n            // artifact-free blur, but not supported everywhere\r\n            this.canvas.style.filter = `url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a' x='0' y='0' width='1' height='1'%3E%3CfeGaussianBlur stdDeviation='${value}' result='b'/%3E%3CfeMorphology operator='dilate' radius='${value}'/%3E %3CfeMerge%3E%3CfeMergeNode/%3E%3CfeMergeNode in='b'/%3E%3C/feMerge%3E%3C/filter%3E%3C/svg%3E#a\")`;\r\n        }\r\n    }\r\n\r\n    public drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        if (lines.length >= 1) {\r\n            applyCanvasCompositing(this.context, color, opacity, operation);\r\n\r\n            this.context.lineWidth = thickness * this.cssPixel;\r\n\r\n            for (const line of lines) {\r\n                this.context.beginPath();\r\n                this.context.moveTo(line.from.x * this.cssPixel, line.from.y * this.cssPixel);\r\n                this.context.lineTo(line.to.x * this.cssPixel, line.to.y * this.cssPixel);\r\n                this.context.stroke();\r\n                this.context.closePath();\r\n            }\r\n\r\n            resetCanvasCompositing(this.context);\r\n        }\r\n    }\r\n\r\n    public drawPoints(points: IPoint[], color: string, diameter: number): void {\r\n        if (points.length > 0) {\r\n            this.context.fillStyle = color;\r\n            this.context.strokeStyle = \"none\";\r\n\r\n            for (const point of points) {\r\n                this.context.beginPath();\r\n                this.context.arc(point.x * this.cssPixel, point.y * this.cssPixel, 0.5 * diameter * this.cssPixel, 0, 2 * Math.PI);\r\n                this.context.fill();\r\n                this.context.closePath();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: Math.floor(this.canvas.width / this.cssPixel),\r\n            height: Math.floor(this.canvas.height / this.cssPixel),\r\n        };\r\n    }\r\n}\r\n\r\nexport { PlotterCanvas2D };\r\n\r\n","import { ILine } from \"../interfaces/i-line\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { computeRawColor, EColor, ECompositingOperation, useAdvancedCompositing } from \"./compositing\";\r\nimport { PlotterBase, IPlotterInfo, ISize } from \"./plotter-base\";\r\nimport { XMLWriter } from \"./xml-writer\";\r\n\r\nconst WIDTH = 1000;\r\nconst HEIGHT = 1000;\r\n\r\nconst BLUR_EFFECT_ID = \"gaussianBlur\";\r\n\r\nclass PlotterSVG extends PlotterBase {\r\n    private hasBlur: boolean;\r\n    private writer: XMLWriter;\r\n\r\n    public constructor() {\r\n        super();\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public resize(): void {\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.writer = new XMLWriter();\r\n\r\n        this.hasBlur = infos.blur > 0;\r\n\r\n        this.writer.addLine(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>`);\r\n        this.writer.startBlock(`<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ${WIDTH} ${HEIGHT}\">`);\r\n\r\n        if (this.hasBlur) {\r\n            this.writer.startBlock(`<defs>`);\r\n            this.writer.startBlock(`<filter id=\"${BLUR_EFFECT_ID}\" x=\"0\" y=\"0\">`);\r\n            this.writer.addLine(`<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"${infos.blur}\"/>`);\r\n            this.writer.endBlock(`</filter>`);\r\n            this.writer.endBlock(`</defs>`);\r\n\r\n            this.writer.startBlock(`<g filter=\"url(#${BLUR_EFFECT_ID})\">`);\r\n\r\n        }\r\n\r\n        const margin = 10;\r\n        this.writer.addLine(`<rect fill=\"white\" stroke=\"none\" x=\"${-margin}\" y=\"${-margin}\" width=\"${WIDTH + 2 * margin}\" height=\"${HEIGHT + 2 * margin}\"/>`);\r\n    }\r\n\r\n    public finalize(): void {\r\n        if (this.hasBlur) {\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n        this.writer.endBlock(`</svg>`);\r\n    }\r\n\r\n    public drawLines(lines: ILine[], color: EColor, opacity: number, operation: ECompositingOperation, thickness: number): void {\r\n        if (lines.length >= 1) {\r\n\r\n            let strokeColor: string;\r\n            if (useAdvancedCompositing()) {\r\n                this.writer.startBlock(`<defs>`);\r\n                this.writer.startBlock(`<style type=\"text/css\">`);\r\n                this.writer.startBlock(`<![CDATA[`);\r\n                this.writer.addLine(`line { mix-blend-mode: difference; }`);\r\n                if (operation === ECompositingOperation.LIGHTEN) {\r\n                    this.writer.addLine(`svg { filter: invert(1); background: black; }`);\r\n                }\r\n                this.writer.endBlock(`]]>`);\r\n                this.writer.endBlock(`</style>`);\r\n                this.writer.endBlock(`</defs>`);\r\n\r\n                const value = Math.ceil(255 * opacity);\r\n                const rawRGB = computeRawColor(color);\r\n                strokeColor = `rgb(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value})`;\r\n            } else {\r\n                const value = (useAdvancedCompositing()) ? 255 : 0;\r\n                const rawRGB = computeRawColor(color);\r\n                strokeColor = `rgba(${rawRGB.r * value}, ${rawRGB.g * value}, ${rawRGB.b * value}, ${opacity})`;\r\n            }\r\n\r\n            // lines container\r\n            this.writer.startBlock(`<g stroke=\"${strokeColor}\" stroke-width=\"${thickness}\" stroke-linecap=\"round\" fill=\"none\">`);\r\n            for (const line of lines) {\r\n                this.writer.addLine(`<line x1=\"${line.from.x.toFixed(1)}\" y1=\"${line.from.y.toFixed(1)}\" x2=\"${line.to.x.toFixed(1)}\" y2=\"${line.to.y.toFixed(1)}\"/>`);\r\n            }\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n    }\r\n\r\n    public drawPoints(points: IPoint[], color: string, diameter: number): void {\r\n        if (points.length > 0) {\r\n            this.writer.startBlock(`<g fill=\"${color}\" stroke=\"none\">`);\r\n            for (const point of points) {\r\n                this.writer.addLine(`<circle cx=\"${point.x.toFixed(1)}\" cy=\"${point.y.toFixed(1)}\" r=\"${0.5 * diameter}\"/>`);\r\n            }\r\n            this.writer.endBlock(`</g>`);\r\n        }\r\n    }\r\n\r\n    public export(): string {\r\n        const start = Date.now();\r\n        const result = this.writer.result;\r\n        console.log(`Concatenation took ${Date.now() - start} ms.`);\r\n        return result;\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: WIDTH,\r\n            height: HEIGHT,\r\n        };\r\n    }\r\n}\r\n\r\nexport { PlotterSVG }\r\n","class XMLWriter {\r\n    private indentationLevel: number = 0;\r\n    private lines: string[] = [];\r\n\r\n    public get result(): string {\r\n        return this.lines.join(\"\\n\");\r\n    }\r\n\r\n    public startBlock(line: string): void {\r\n        this.addLine(line);\r\n        this.indentationLevel++;\r\n    }\r\n\r\n    public endBlock(line: string): void {\r\n        this.indentationLevel--;\r\n        this.addLine(line);\r\n    }\r\n\r\n    public addLine(line: string): void {\r\n        this.lines.push(this.prefix + line);\r\n    }\r\n\r\n    private get prefix(): string {\r\n        return \"\\t\".repeat(this.indentationLevel);\r\n    }\r\n}\r\n\r\nexport { XMLWriter };\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { EMode, EShape, Parameters } from \"../parameters\";\r\nimport { PlotterBase } from \"../plotter/plotter-base\";\r\nimport { Transformation } from \"./transformation\";\r\nimport { applyCanvasCompositing, EColor, ECompositingOperation, resetCanvasCompositing } from \"../plotter/compositing\";\r\n\r\nimport { ThreadMonochrome } from \"./thread/thread-monochrome\";\r\nimport { ThreadRedBlueGreen } from \"./thread/thread-red-green-blue\";\r\nimport { ThreadBase } from \"./thread/thread-base\";\r\n\r\nconst MIN_SAFE_NUMBER = -9007199254740991;\r\nconst TWO_PI = 2 * Math.PI;\r\n\r\nfunction clamp(x: number, min: number, max: number): number {\r\n    if (x < min) {\r\n        return min;\r\n    } else if (x > max) {\r\n        return max;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mix(a: number, b: number, x: number): number {\r\n    return a * (1 - x) + b * x;\r\n}\r\n\r\nfunction distance(p1: IPoint, p2: IPoint): number {\r\n    const dX = p1.x - p2.x;\r\n    const dY = p1.y - p2.y;\r\n    return Math.sqrt(dX * dX + dY * dY);\r\n}\r\n\r\nfunction randomItem<T>(list: T[]): T {\r\n    if (list.length === 0) {\r\n        return null;\r\n    }\r\n    const randomIndex = Math.floor(Math.random() * list.length);\r\n    return list[randomIndex];\r\n}\r\n\r\ninterface IPeg {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\ninterface ISegment {\r\n    peg1: IPeg;\r\n    peg2: IPeg;\r\n}\r\n\r\ninterface IErrorMeasure {\r\n    average: number;\r\n    variance: number;\r\n    meanSquare: number;\r\n}\r\n\r\ntype IndicatorUpdateFunction = (indicatorId: string, indicatorValue: string) => unknown;\r\n\r\n/**\r\n * Class used to compute which thread path is the best choice.\r\n */\r\nclass ThreadComputer {\r\n    private readonly sourceImage: HTMLImageElement;\r\n    private readonly hiddenCanvas: HTMLCanvasElement;\r\n    private readonly hiddenCanvasContext: CanvasRenderingContext2D;\r\n    private hiddenCanvasData: ImageData = null\r\n    private hiddenCanvasScale: number;\r\n\r\n    private error: IErrorMeasure;\r\n\r\n    private pegs: IPeg[];\r\n\r\n    private lineOpacity: number; // in the final result\r\n    private lineOpacityInternal: number;\r\n    private lineThickness: number; // abstract unit\r\n\r\n    private thread: ThreadBase;\r\n\r\n    private arePegsTooClose: (peg1: IPeg, peg2: IPeg) => boolean;\r\n\r\n    public constructor(image: HTMLImageElement) {\r\n        this.sourceImage = image;\r\n\r\n        this.hiddenCanvas = document.createElement(\"canvas\");\r\n        this.hiddenCanvasContext = this.hiddenCanvas.getContext(\"2d\");\r\n\r\n        this.reset(16 / 256, 1);\r\n    }\r\n\r\n    public drawThread(plotter: PlotterBase, nbSegmentsToIgnore: number): void {\r\n        const transformation = this.computeTransformation(plotter.size);\r\n        const lineWidth = (transformation.scaling * this.hiddenCanvasScale) * this.lineThickness;\r\n        const compositing = Parameters.invertColors ? ECompositingOperation.LIGHTEN : ECompositingOperation.DARKEN;\r\n\r\n        this.thread.iterateOnThreads(nbSegmentsToIgnore, (thread: IPeg[], color: EColor) => {\r\n            const points: IPoint[] = [];\r\n            for (const peg of thread) {\r\n                points.push(transformation.transform(peg));\r\n            }\r\n\r\n            plotter.drawBrokenLine(points, color, this.lineOpacity, compositing, lineWidth);\r\n        });\r\n    }\r\n\r\n    public drawPegs(plotter: PlotterBase): void {\r\n        const transformation = this.computeTransformation(plotter.size);\r\n        const pointSize = 0.5 * (transformation.scaling * this.hiddenCanvasScale);\r\n\r\n        const points: IPoint[] = [];\r\n        for (const peg of this.pegs) {\r\n            points.push(transformation.transform(peg));\r\n        }\r\n\r\n        plotter.drawPoints(points, \"red\", pointSize);\r\n    }\r\n\r\n    public drawDebugView(targetContext: CanvasRenderingContext2D): void {\r\n        targetContext.drawImage(this.hiddenCanvas, 0, 0, this.hiddenCanvas.width, this.hiddenCanvas.height);\r\n    }\r\n\r\n    /** Returns true if there is nothing more to compute */\r\n    public computeNextSegments(maxMillisecondsTaken: number): boolean {\r\n        const start = performance.now();\r\n\r\n        const targetNbSegments = Parameters.nbLines;\r\n        if (this.nbSegments === targetNbSegments) {\r\n            // no new segment to compute\r\n            return false;\r\n        } else if (this.nbSegments > targetNbSegments) {\r\n            // we drew too many lines already, removes the excess\r\n            this.thread.lowerNbSegments(targetNbSegments);\r\n\r\n            // redraw the hidden canvas from scratch\r\n            this.resetHiddenCanvas();\r\n            this.thread.iterateOnThreads(0, (thread: IPeg[], color: EColor) => {\r\n                applyCanvasCompositing(this.hiddenCanvasContext, color, this.lineOpacityInternal, ECompositingOperation.LIGHTEN);\r\n\r\n                for (let iPeg = 0; iPeg + 1 < thread.length; iPeg++) {\r\n                    this.drawSegmentOnHiddenCanvas(thread[iPeg], thread[iPeg + 1]);\r\n                }\r\n            });\r\n\r\n            this.computeError();\r\n            return true;\r\n        }\r\n\r\n        let lastColor: EColor = null;\r\n        while (this.nbSegments < targetNbSegments && performance.now() - start < maxMillisecondsTaken) {\r\n            const threadToGrow = this.thread.getThreadToGrow();\r\n\r\n            if (lastColor !== threadToGrow.color) {\r\n                applyCanvasCompositing(this.hiddenCanvasContext, threadToGrow.color, this.lineOpacityInternal, ECompositingOperation.LIGHTEN);\r\n                this.thread.enableSamplingFor(threadToGrow.color);\r\n                lastColor = threadToGrow.color;\r\n            }\r\n            this.computeSegment(threadToGrow.thread);\r\n\r\n            if (this.nbSegments % 100 === 0) {\r\n                this.computeError();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param opacity in [0,1]\r\n     * @returns true if at least one parameter changed\r\n     */\r\n    public reset(opacity: number, linethickness: number): void {\r\n        this.lineOpacity = opacity;\r\n        this.lineThickness = linethickness;\r\n\r\n        this.hiddenCanvasScale = Parameters.quality;\r\n\r\n        if (Parameters.mode === EMode.MONOCHROME) {\r\n            this.thread = new ThreadMonochrome();\r\n        } else {\r\n            this.thread = new ThreadRedBlueGreen();\r\n        }\r\n        this.resetHiddenCanvas();\r\n\r\n        this.pegs = this.computePegs();\r\n    }\r\n\r\n    public updateIndicators(updateFunction: IndicatorUpdateFunction): void {\r\n        updateFunction(\"pegs-count\", this.pegs.length.toString());\r\n        updateFunction(\"segments-count\", this.nbSegments.toString());\r\n        updateFunction(\"error-average\", this.error.average.toString());\r\n        updateFunction(\"error-mean-square\", this.error.meanSquare.toString());\r\n        updateFunction(\"error-variance\", this.error.variance.toString());\r\n    }\r\n\r\n    public get nbSegments(): number {\r\n        return this.thread.totalNbSegments;\r\n    }\r\n\r\n    public get instructions(): string {\r\n        if (Parameters.mode !== EMode.MONOCHROME) {\r\n            return \"Instructions are only available for monochrome mode.\";\r\n        }\r\n        if (Parameters.invertColors) {\r\n            return \"Instructions are only available for black thread.\";\r\n        }\r\n\r\n        let domainWidth = -1;\r\n        let domainHeight = -1;\r\n        for (const peg of this.pegs) {\r\n            if (domainWidth < peg.x) {\r\n                domainWidth = peg.x;\r\n            }\r\n            if (domainHeight < peg.y) {\r\n                domainHeight = peg.y;\r\n            }\r\n        }\r\n\r\n        const instructions: string[] = [];\r\n        instructions.push(\"Generated by https://piellardj.github.io/image-stylization-threading.\\n\");\r\n        instructions.push(\"Here are instructions to reproduce this in real life. For the best result, make sure you used the website at the highest quality mode and the highest thread opacity.\\n\");\r\n\r\n        instructions.push(`Space units used below are abstract, just scale it to whatever size you want. Typically, you can choose 1 unit = 1 millimeter.`);\r\n        instructions.push(`Computed for a total size of ${domainWidth}x${domainHeight}.`);\r\n        const threadThickness = this.lineThickness * this.hiddenCanvasScale;\r\n        instructions.push(`Computed for a black thread of width ${threadThickness} and opacity ${this.lineOpacity} (this is equivalent to an opaque thread of width ${threadThickness * this.lineOpacity}).`);\r\n\r\n        instructions.push(\"\\nFirst here are the positions of the pegs:\");\r\n\r\n        interface INamedPeg extends IPeg {\r\n            name: string;\r\n        }\r\n\r\n        const namedPegs = this.pegs as INamedPeg[];\r\n        for (let iP = 0; iP < namedPegs.length; iP++) {\r\n            namedPegs[iP].name = `PEG_${iP}`;\r\n            instructions.push(`  - ${namedPegs[iP].name}: x=${namedPegs[iP].x.toFixed(2)} ; y=${namedPegs[iP].y.toFixed(2)}`);\r\n        }\r\n\r\n        instructions.push(\"\\nThen here are the steps of the thread:\");\r\n\r\n        this.thread.iterateOnThreads(0, (thread: IPeg[]) => {\r\n            const namedThread = thread as INamedPeg[];\r\n            instructions.push(`  - First start from ${namedThread[0].name}`);\r\n            for (let iP = 1; iP < namedThread.length; iP++) {\r\n                instructions.push(`  - then go to ${namedThread[iP].name} (this is segment ${iP} / ${namedThread.length - 1})`);\r\n            }\r\n        });\r\n\r\n        return instructions.join(\"\\n\");\r\n    }\r\n\r\n    private initializeHiddenCanvasLineProperties(): void {\r\n        const theoricalThicknes = this.lineThickness * this.hiddenCanvasScale;\r\n\r\n        if (theoricalThicknes <= 1) {\r\n            // do not go below a line width of 1 because it creates artifact.\r\n            // instead, lower the lines opacity.\r\n            this.lineOpacityInternal = 0.5 * this.lineOpacity * theoricalThicknes;\r\n            this.hiddenCanvasContext.lineWidth = 1;\r\n        } else {\r\n            this.lineOpacityInternal = 0.5 * this.lineOpacity;\r\n            this.hiddenCanvasContext.lineWidth = theoricalThicknes;\r\n        }\r\n    }\r\n\r\n    private computeSegment(thread: IPeg[]): void {\r\n        let lastPeg: IPeg;\r\n        let nextPeg: IPeg;\r\n\r\n        if (thread.length === 0) {\r\n            const startingSegment = this.computeBestStartingSegment();\r\n            thread.push(startingSegment.peg1);\r\n            lastPeg = startingSegment.peg1;\r\n            nextPeg = startingSegment.peg2;\r\n        } else {\r\n            lastPeg = thread[thread.length - 1];\r\n            const HISTORY_SIZE = Math.min(thread.length, 20);\r\n            const prevousPegs = thread.slice(-HISTORY_SIZE);\r\n            nextPeg = this.computeBestNextPeg(lastPeg, prevousPegs);\r\n        }\r\n\r\n        thread.push(nextPeg);\r\n        this.drawSegmentOnHiddenCanvas(lastPeg, nextPeg);\r\n    }\r\n\r\n    private resetHiddenCanvas(): void {\r\n        const wantedSize = ThreadComputer.computeBestSize(this.sourceImage, 100 * this.hiddenCanvasScale);\r\n        this.hiddenCanvas.width = wantedSize.width;\r\n        this.hiddenCanvas.height = wantedSize.height;\r\n\r\n        resetCanvasCompositing(this.hiddenCanvasContext);\r\n        this.hiddenCanvasContext.drawImage(this.sourceImage, 0, 0, wantedSize.width, wantedSize.height);\r\n\r\n        // change the base level so that pure white becomes medium grey\r\n        const imageData = this.hiddenCanvasContext.getImageData(0, 0, wantedSize.width, wantedSize.height);\r\n        this.thread.adjustCanvasData(imageData.data, Parameters.invertColors);\r\n        this.hiddenCanvasContext.putImageData(imageData, 0, 0);\r\n        this.computeError();\r\n\r\n        this.initializeHiddenCanvasLineProperties();\r\n    }\r\n\r\n    private computeError(): void {\r\n        this.uploadCanvasDataToCPU();\r\n\r\n        this.error = {\r\n            average: 0,\r\n            variance: 0,\r\n            meanSquare: 0,\r\n        };\r\n\r\n        const nbPixels = this.hiddenCanvasData.width * this.hiddenCanvasData.height;\r\n        const nbSamples = 3 * nbPixels;\r\n        for (let iP = 0; iP < nbPixels; iP++) {\r\n            const errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];\r\n            const errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];\r\n            const errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];\r\n\r\n            this.error.average += errorRed + errorGreen + errorBlue;\r\n            this.error.meanSquare += (errorRed * errorRed) + (errorGreen * errorGreen) + (errorBlue * errorBlue);\r\n        }\r\n        this.error.average = Math.round(this.error.average / nbSamples);\r\n        this.error.meanSquare = Math.round(this.error.meanSquare / nbSamples);\r\n\r\n        for (let iP = 0; iP < nbPixels; iP++) {\r\n            const errorRed = 127 - this.hiddenCanvasData.data[4 * iP + 0];\r\n            const errorGreen = 127 - this.hiddenCanvasData.data[4 * iP + 1];\r\n            const errorBlue = 127 - this.hiddenCanvasData.data[4 * iP + 2];\r\n            const error = (errorRed + errorGreen + errorBlue) / 3;\r\n            const distancetoError = error - this.error.average;\r\n            this.error.variance += distancetoError * distancetoError;\r\n        }\r\n        this.error.variance = Math.round(this.error.variance / nbSamples);\r\n    }\r\n\r\n    private computeTransformation(targetSize: ISize): Transformation {\r\n        return new Transformation(targetSize, this.hiddenCanvas);\r\n    }\r\n\r\n    private drawSegmentOnHiddenCanvas(peg1: IPeg, peg2: IPeg): void {\r\n        this.hiddenCanvasContext.beginPath();\r\n        this.hiddenCanvasContext.moveTo(peg1.x, peg1.y);\r\n        this.hiddenCanvasContext.lineTo(peg2.x, peg2.y);\r\n        this.hiddenCanvasContext.stroke();\r\n        this.hiddenCanvasContext.closePath();\r\n\r\n        // invalidate CPU data\r\n        this.hiddenCanvasData = null;\r\n    }\r\n\r\n    private computeBestStartingSegment(): ISegment {\r\n        let candidates: ISegment[] = [];\r\n        let bestScore = MIN_SAFE_NUMBER;\r\n\r\n        const step = 1 + Math.floor(this.pegs.length / 100);\r\n        for (let iPegId1 = 0; iPegId1 < this.pegs.length; iPegId1 += step) {\r\n            for (let iPegId2 = iPegId1 + 1; iPegId2 < this.pegs.length; iPegId2 += step) {\r\n                const peg1 = this.pegs[iPegId1];\r\n                const peg2 = this.pegs[iPegId2];\r\n\r\n                if (!this.arePegsTooClose(peg1, peg2)) {\r\n                    const candidateScore = this.computeSegmentPotential(peg1, peg2);\r\n                    if (candidateScore > bestScore) {\r\n                        bestScore = candidateScore;\r\n                        candidates = [{ peg1, peg2, }];\r\n                    } else if (candidateScore === bestScore) {\r\n                        candidates.push({ peg1, peg2, });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return randomItem(candidates);\r\n    }\r\n\r\n    private computeBestNextPeg(currentPeg: IPeg, pegsToAvoid: IPeg[]): IPeg {\r\n        let candidates: IPeg[] = [];\r\n        let bestScore = MIN_SAFE_NUMBER;\r\n\r\n        for (const peg of this.pegs) {\r\n            if (!this.arePegsTooClose(currentPeg, peg) && !pegsToAvoid.includes(peg)) {\r\n                const candidateScore = this.computeSegmentPotential(currentPeg, peg);\r\n                if (candidateScore > bestScore) {\r\n                    bestScore = candidateScore;\r\n                    candidates = [peg];\r\n                } else if (candidateScore === bestScore) {\r\n                    candidates.push(peg);\r\n                }\r\n            }\r\n        }\r\n\r\n        return randomItem(candidates);\r\n    }\r\n\r\n    private uploadCanvasDataToCPU(): void {\r\n        if (this.hiddenCanvasData === null) {\r\n            const width = this.hiddenCanvas.width;\r\n            const height = this.hiddenCanvas.height;\r\n            this.hiddenCanvasData = this.hiddenCanvasContext.getImageData(0, 0, width, height);\r\n        }\r\n    }\r\n\r\n    /* The higher the result, the better a choice the thread is. */\r\n    private computeSegmentPotential(peg1: IPeg, peg2: IPeg): number {\r\n        this.uploadCanvasDataToCPU();\r\n\r\n        let potential = 0;\r\n\r\n        const segmentLength = distance(peg1, peg2);\r\n        const nbSamples = Math.ceil(segmentLength);\r\n        for (let iSample = 0; iSample < nbSamples; iSample++) {\r\n            const r = (iSample + 1) / (nbSamples + 1);\r\n            const sample: IPoint = {\r\n                x: mix(peg1.x, peg2.x, r),\r\n                y: mix(peg1.y, peg2.y, r),\r\n            };\r\n\r\n            const imageValue = this.sampleCanvasData(sample);\r\n            const finalValue = imageValue + (this.lineOpacityInternal * 255);\r\n            const contribution = 127 - finalValue;\r\n            potential += contribution;\r\n        }\r\n\r\n        return potential / nbSamples;\r\n    }\r\n\r\n    /** Linear interpolation. Returns a result in [0, 255] */\r\n    private sampleCanvasData(coords: IPoint): number {\r\n        const width = this.hiddenCanvasData.width;\r\n        const height = this.hiddenCanvasData.height;\r\n\r\n        const minX = clamp(Math.floor(coords.x), 0, width - 1);\r\n        const maxX = clamp(Math.ceil(coords.x), 0, width - 1);\r\n        const minY = clamp(Math.floor(coords.y), 0, height - 1);\r\n        const maxY = clamp(Math.ceil(coords.y), 0, height - 1);\r\n\r\n        const topLeft = this.sampleCanvasPixel(minX, minY);\r\n        const topRight = this.sampleCanvasPixel(maxX, minY);\r\n        const bottomLeft = this.sampleCanvasPixel(minX, maxY);\r\n        const bottomRight = this.sampleCanvasPixel(maxX, maxY);\r\n\r\n        const fractX = coords.x % 1;\r\n        const top = mix(topLeft, topRight, fractX);\r\n        const bottom = mix(bottomLeft, bottomRight, fractX);\r\n\r\n        const fractY = coords.y % 1;\r\n        return mix(top, bottom, fractY);\r\n    }\r\n\r\n    private sampleCanvasPixel(pixelX: number, pixelY: number): number {\r\n        const index = 4 * (pixelX + pixelY * this.hiddenCanvasData.width);\r\n        return this.thread.sampleCanvas(this.hiddenCanvasData.data, index);\r\n    }\r\n\r\n    private static computeBestSize(sourceImageSize: ISize, maxSize: number): ISize {\r\n        const maxSourceSide = Math.max(sourceImageSize.width, sourceImageSize.height);\r\n        const sizingFactor = maxSize / maxSourceSide;\r\n        return {\r\n            width: Math.ceil(sourceImageSize.width * sizingFactor),\r\n            height: Math.ceil(sourceImageSize.height * sizingFactor),\r\n        };\r\n    }\r\n\r\n    private computePegs(): IPeg[] {\r\n        /* First, compute pegs for a fixed-size canvas*/\r\n        let domainSize: ISize;\r\n        {\r\n            const DEFAULT_CANVAS_SIZE_FOR_PEGS = 1000;\r\n            const aspectRatio = this.hiddenCanvas.width / this.hiddenCanvas.height;\r\n            if (aspectRatio > 1) {\r\n                domainSize = { width: DEFAULT_CANVAS_SIZE_FOR_PEGS, height: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS / aspectRatio) };\r\n            } else {\r\n                domainSize = { width: Math.round(DEFAULT_CANVAS_SIZE_FOR_PEGS * aspectRatio), height: DEFAULT_CANVAS_SIZE_FOR_PEGS };\r\n            }\r\n        }\r\n        const pegsShape = Parameters.shape;\r\n        const pegsCount = Parameters.pegsCount;\r\n\r\n        const pegs: IPeg[] = [];\r\n\r\n        if (pegsShape === EShape.RECTANGLE) {\r\n            this.arePegsTooClose = (peg1: IPeg, peg2: IPeg) => {\r\n                return peg1.x === peg2.x || peg1.y === peg2.y;\r\n            };\r\n\r\n            const maxX = domainSize.width;\r\n            const maxY = domainSize.height;\r\n\r\n            const aspectRatio = maxY / maxX;\r\n            const nbPegsPerWidth = Math.round(0.5 * pegsCount / (1 + aspectRatio));\r\n            const nbPegsPerHeight = Math.round(0.5 * (pegsCount - 2 * nbPegsPerWidth));\r\n\r\n            pegs.push({ x: 0, y: 0 });\r\n\r\n            for (let iW = 1; iW < nbPegsPerWidth; iW++) {\r\n                pegs.push({ x: maxX * (iW / nbPegsPerWidth), y: 0 });\r\n            }\r\n\r\n            pegs.push({ x: maxX, y: 0 });\r\n\r\n            for (let iH = 1; iH < nbPegsPerHeight; iH++) {\r\n                pegs.push({ x: maxX, y: maxY * (iH / nbPegsPerHeight) });\r\n            }\r\n\r\n            pegs.push({ x: maxX, y: maxY });\r\n\r\n            for (let iW = nbPegsPerWidth - 1; iW >= 1; iW--) {\r\n                pegs.push({ x: maxX * (iW / nbPegsPerWidth), y: maxY });\r\n            }\r\n\r\n            pegs.push({ x: 0, y: maxY });\r\n\r\n            for (let iH = nbPegsPerHeight - 1; iH >= 1; iH--) {\r\n                pegs.push({ x: 0, y: maxY * (iH / nbPegsPerHeight) });\r\n            }\r\n        } else {\r\n            interface IPegCircle extends IPeg {\r\n                angle: number;\r\n            }\r\n\r\n            this.arePegsTooClose = (peg1: IPeg, peg2: IPeg) => {\r\n                const absDeltaAngle = Math.abs((peg1 as IPegCircle).angle - (peg2 as IPegCircle).angle);\r\n                const minAngle = Math.min(absDeltaAngle, TWO_PI - absDeltaAngle);\r\n                return minAngle <= TWO_PI / 16;\r\n            };\r\n\r\n            const halfWidth = 0.5 * domainSize.width;\r\n            const halfHeight = 0.5 * domainSize.height;\r\n            const circumference = Math.PI * (3 * (halfWidth + halfHeight) - Math.sqrt((3 * halfWidth + halfHeight) * (halfWidth + 3 * halfHeight)));\r\n            const distanceBetweenPegs = circumference / pegsCount;\r\n            let angle = 0;\r\n            while (pegs.length < pegsCount) {\r\n                const cosAngle = Math.cos(angle);\r\n                const sinAngle = Math.sin(angle);\r\n\r\n                const peg: IPegCircle = {\r\n                    x: halfWidth * (1 + cosAngle),\r\n                    y: halfHeight * (1 + sinAngle),\r\n                    angle,\r\n                }\r\n                pegs.push(peg);\r\n\r\n                // compute the delta angle so that pegs are evenly-spaced even on ellipses\r\n                const deltaAngle = distanceBetweenPegs / Math.sqrt(halfWidth * halfWidth * sinAngle * sinAngle + halfHeight * halfHeight * cosAngle * cosAngle);\r\n                angle += deltaAngle;\r\n            }\r\n        }\r\n\r\n        /* Then adjust the pegs to the actual canvas size */\r\n        for (const peg of pegs) {\r\n            peg.x *= this.hiddenCanvas.width / domainSize.width;\r\n            peg.y *= this.hiddenCanvas.height / domainSize.height;\r\n        }\r\n\r\n        return pegs;\r\n    }\r\n}\r\n\r\nexport { ThreadComputer, IPeg };\r\n","import { Parameters } from \"../parameters\";\r\nimport { IPlotterInfo, PlotterBase } from \"../plotter/plotter-base\";\r\nimport { ThreadComputer } from \"./thread-computer\";\r\n\r\nclass ThreadPlotter {\r\n    private nbSegmentsDrawn: number = 0;\r\n\r\n    public constructor(private readonly plotter: PlotterBase, private readonly threadComputer: ThreadComputer) { }\r\n\r\n    public reset(): void {\r\n        this.nbSegmentsDrawn = 0;\r\n    }\r\n\r\n    public plot(): void {\r\n        if (this.nbSegmentsDrawn === this.threadComputer.nbSegments) {\r\n            // nothing more to do\r\n            return;\r\n        } else if (this.nbSegmentsDrawn > this.threadComputer.nbSegments) {\r\n            // if the nb of segment went down, no other choice that redrawing all from scratch\r\n            this.nbSegmentsDrawn = 0;\r\n        }\r\n\r\n        const drawFromScratch = (this.nbSegmentsDrawn === 0);\r\n        if (drawFromScratch) {\r\n            const plotterInfos: IPlotterInfo = {\r\n                backgroundColor: Parameters.invertColors ? \"black\" : \"white\",\r\n                blur: Parameters.blur,\r\n            };\r\n\r\n            this.plotter.resize();\r\n            this.plotter.initialize(plotterInfos);\r\n\r\n            if (Parameters.displayPegs) {\r\n                this.threadComputer.drawPegs(this.plotter);\r\n            }\r\n\r\n            this.threadComputer.drawThread(this.plotter, 0);\r\n            this.plotter.finalize();\r\n        } else {\r\n            this.threadComputer.drawThread(this.plotter, this.nbSegmentsDrawn);\r\n        }\r\n\r\n        this.nbSegmentsDrawn = this.threadComputer.nbSegments;\r\n    }\r\n}\r\n\r\nexport { ThreadPlotter };\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\ntype ThreadsIterator = (thread: IPeg[], color: EColor) => unknown;\r\n\r\ntype SamplingFunction = (data: Uint8ClampedArray, index: number) => number;\r\n\r\ninterface IThreadToGrow {\r\n    thread: IPeg[];\r\n    color: EColor;\r\n}\r\n\r\nabstract class ThreadBase {\r\n    public abstract get totalNbSegments(): number;\r\n\r\n    public abstract lowerNbSegments(targetNumber: number): void;\r\n\r\n    public abstract iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void;\r\n\r\n    public abstract getThreadToGrow(): IThreadToGrow;\r\n\r\n    public abstract adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void;\r\n\r\n    public abstract enableSamplingFor(color: EColor): void;\r\n\r\n    /**\r\n     * @returns value in [0, 255]. Ideal value is 127\r\n     */\r\n    public sampleCanvas: SamplingFunction = null;\r\n\r\n    protected static lowerNbSegmentsForThread(thread: IPeg[], targetNumber: number): void {\r\n        if (targetNumber > 0) {\r\n            thread.length = Math.min(thread.length, targetNumber + 1);\r\n        } else {\r\n            thread.length = 0;\r\n        }\r\n    }\r\n\r\n    protected static computeNbSegments(thread: IPeg[]): number {\r\n        return (thread.length > 1) ? thread.length - 1 : 0;\r\n    }\r\n\r\n    public static iterateOnThread(thread: IPeg[], color: EColor, fromSegmentNumber: number, callback: ThreadsIterator): void {\r\n        const threadLength = ThreadBase.computeNbSegments(thread);\r\n        if (fromSegmentNumber < threadLength) {\r\n            const threadPart = thread.slice(fromSegmentNumber);\r\n            callback(threadPart, color);\r\n        }\r\n    }\r\n}\r\n\r\nexport {\r\n    IThreadToGrow,\r\n    ThreadBase,\r\n    ThreadsIterator,\r\n};\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\nimport { IThreadToGrow, ThreadBase, ThreadsIterator } from \"./thread-base\";\r\n\r\nclass ThreadMonochrome extends ThreadBase {\r\n    private threadPegs: IPeg[] = [];\r\n\r\n    public get totalNbSegments(): number {\r\n        return ThreadBase.computeNbSegments(this.threadPegs);\r\n    }\r\n\r\n    public lowerNbSegments(targetNumber: number): void {\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegs, targetNumber);\r\n    }\r\n\r\n    public iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void {\r\n        ThreadBase.iterateOnThread(this.threadPegs, EColor.MONOCHROME, nbSegmentsToIgnore, callback);\r\n    }\r\n\r\n    public getThreadToGrow(): IThreadToGrow {\r\n        return {\r\n            thread: this.threadPegs,\r\n            color: EColor.MONOCHROME,\r\n        }\r\n    }\r\n\r\n    public adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void {\r\n        let computeAdjustedValue: (rawValue: number) => number;\r\n        if (blackBackground) {\r\n            computeAdjustedValue = (rawValue: number) => (255 - rawValue) / 2;\r\n        } else {\r\n            computeAdjustedValue = (rawValue: number) => rawValue / 2;\r\n        }\r\n\r\n        const nbPixels = data.length / 4;\r\n        for (let i = 0; i < nbPixels; i++) {\r\n            const averageSourceValue = (data[4 * i + 0] + data[4 * i + 1] + data[4 * i + 2]) / 3;\r\n            const adjustedValue = computeAdjustedValue(averageSourceValue);\r\n            data[4 * i + 0] = adjustedValue;\r\n            data[4 * i + 1] = adjustedValue;\r\n            data[4 * i + 2] = adjustedValue;\r\n        }\r\n    }\r\n\r\n    public enableSamplingFor(): void {\r\n        if (this.sampleCanvas === null) {\r\n            this.sampleCanvas = (data: Uint8ClampedArray, index: number) => {\r\n                return data[index + 0]; // only check the red channel because the hidden canvas is in black and white\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport { ThreadMonochrome };\r\n","import { EColor } from \"../../plotter/compositing\";\r\nimport { IPeg } from \"../thread-computer\";\r\n\r\nimport { IThreadToGrow, ThreadBase, ThreadsIterator } from \"./thread-base\";\r\n\r\ninterface ISegmentsRepartition {\r\n    red: number;\r\n    green: number;\r\n    blue: number;\r\n}\r\n\r\nclass ThreadRedBlueGreen extends ThreadBase {\r\n    private threadPegsRed: IPeg[] = [];\r\n    private threadPegsGreen: IPeg[] = [];\r\n    private threadPegsBlue: IPeg[] = [];\r\n\r\n    // indicators describing the colors repartition from the source image\r\n    private frequencyRed: number;\r\n    private frequencyGreen: number;\r\n    private frequencyBlue: number;\r\n\r\n    public get totalNbSegments(): number {\r\n        return ThreadBase.computeNbSegments(this.threadPegsRed) +\r\n            ThreadBase.computeNbSegments(this.threadPegsGreen) +\r\n            ThreadBase.computeNbSegments(this.threadPegsBlue);\r\n    }\r\n\r\n    public lowerNbSegments(targetNumber: number): void {\r\n        const repartition = this.computeIdealSegmentsRepartition(targetNumber);\r\n\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsRed, repartition.red);\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsGreen, repartition.green);\r\n        ThreadBase.lowerNbSegmentsForThread(this.threadPegsBlue, repartition.blue);\r\n    }\r\n\r\n    public iterateOnThreads(nbSegmentsToIgnore: number, callback: ThreadsIterator): void {\r\n        const repartition = this.computeIdealSegmentsRepartition(nbSegmentsToIgnore);\r\n\r\n        ThreadBase.iterateOnThread(this.threadPegsRed, EColor.RED, repartition.red, callback);\r\n        ThreadBase.iterateOnThread(this.threadPegsGreen, EColor.GREEN, repartition.green, callback);\r\n        ThreadBase.iterateOnThread(this.threadPegsBlue, EColor.BLUE, repartition.blue, callback);\r\n    }\r\n\r\n    public getThreadToGrow(): IThreadToGrow {\r\n        const repartition = this.computeIdealSegmentsRepartition(this.totalNbSegments + 1);\r\n        if (repartition.red > 0 && this.threadPegsRed.length < repartition.red + 1) {\r\n            return {\r\n                thread: this.threadPegsRed,\r\n                color: EColor.RED,\r\n            };\r\n        } else if (repartition.green > 0 && this.threadPegsGreen.length < repartition.green + 1) {\r\n            return {\r\n                thread: this.threadPegsGreen,\r\n                color: EColor.GREEN,\r\n            };\r\n        }\r\n\r\n        return {\r\n            thread: this.threadPegsBlue,\r\n            color: EColor.BLUE,\r\n        };\r\n    }\r\n\r\n    public adjustCanvasData(data: Uint8ClampedArray, blackBackground: boolean): void {\r\n        let cumulatedRed = 0;\r\n        let cumulatedGreen = 0;\r\n        let cumulatedBlue = 0;\r\n\r\n        let computeAdjustedValue: (rawValue: number) => number;\r\n        if (blackBackground) {\r\n            computeAdjustedValue = (rawValue: number) => (255 - rawValue) / 2;\r\n        } else {\r\n            computeAdjustedValue = (rawValue: number) => rawValue / 2;\r\n        }\r\n\r\n        const nbPixels = data.length / 4;\r\n        for (let i = 0; i < nbPixels; i++) {\r\n            cumulatedRed += data[4 * i + 0];\r\n            cumulatedGreen += data[4 * i + 1];\r\n            cumulatedBlue += data[4 * i + 2];\r\n\r\n            data[4 * i + 0] = computeAdjustedValue(data[4 * i + 0]);\r\n            data[4 * i + 1] = computeAdjustedValue(data[4 * i + 1]);\r\n            data[4 * i + 2] = computeAdjustedValue(data[4 * i + 2]);\r\n        }\r\n\r\n        if (!blackBackground) {\r\n            cumulatedRed = 255 * nbPixels - cumulatedRed;\r\n            cumulatedGreen = 255 * nbPixels - cumulatedGreen;\r\n            cumulatedBlue = 255 * nbPixels - cumulatedBlue;\r\n        }\r\n\r\n        const totalColor = cumulatedRed + cumulatedGreen + cumulatedBlue;\r\n        this.frequencyRed = cumulatedRed / totalColor;\r\n        this.frequencyGreen = cumulatedGreen / totalColor;\r\n        this.frequencyBlue = cumulatedBlue / totalColor;\r\n    }\r\n\r\n    public enableSamplingFor(color: EColor): void {\r\n        let channel: number;\r\n        if (color === EColor.RED) {\r\n            channel = 0;\r\n        } else if (color === EColor.GREEN) {\r\n            channel = 1;\r\n        } else {\r\n            channel = 2;\r\n        }\r\n\r\n        this.sampleCanvas = (data: Uint8ClampedArray, index: number) => {\r\n            return data[index + channel];\r\n        }\r\n    }\r\n\r\n    private computeIdealSegmentsRepartition(totalNbSegments: number): ISegmentsRepartition {\r\n        const idealRed = totalNbSegments * this.frequencyRed;\r\n        const idealGreen = totalNbSegments * this.frequencyGreen;\r\n        const idealBlue = totalNbSegments * this.frequencyBlue;\r\n\r\n        const repartition = {\r\n            red: Math.floor(idealRed),\r\n            green: Math.floor(idealGreen),\r\n            blue: Math.floor(idealBlue),\r\n        };\r\n\r\n        while (repartition.red + repartition.green + repartition.blue < totalNbSegments) {\r\n            const currentFrequencyRed = repartition.red / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n            const currentFrequencyGreen = repartition.green / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n            const currentFrequencyBlue = repartition.blue / Math.max(1, repartition.red + repartition.green + repartition.blue);\r\n\r\n            const gapRed = idealRed - currentFrequencyRed;\r\n            const gapGreen = idealGreen - currentFrequencyGreen;\r\n            const gapBlue = idealBlue - currentFrequencyBlue;\r\n\r\n            if (gapRed > gapGreen && gapRed > gapBlue) {\r\n                repartition.red++;\r\n            } else if (gapGreen > gapRed && gapGreen > gapBlue) {\r\n                repartition.green++;\r\n            } else {\r\n                repartition.blue++;\r\n            }\r\n        }\r\n\r\n        return repartition;\r\n    }\r\n}\r\n\r\nexport { ThreadRedBlueGreen };\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\n\r\nclass Transformation {\r\n    public readonly scaling: number;\r\n    public readonly origin: IPoint;\r\n\r\n    public constructor(frameSize: ISize, elementSize: ISize) {\r\n        const scaleToFitWidth = frameSize.width / elementSize.width;\r\n        const scaleToFitHeight = frameSize.height / elementSize.height;\r\n\r\n        this.scaling = Math.min(scaleToFitWidth, scaleToFitHeight);\r\n        this.origin = {\r\n            x: 0.5 * (frameSize.width - this.scaling * elementSize.width),\r\n            y: 0.5 * (frameSize.height - this.scaling * elementSize.height)\r\n        };\r\n    }\r\n\r\n    public transform(point: IPoint): IPoint {\r\n        return {\r\n            x: this.origin.x + point.x * this.scaling,\r\n            y: this.origin.y + point.y * this.scaling,\r\n        };\r\n    }\r\n}\r\n\r\nexport { Transformation };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(633);\n"],"names":["downloadTextFile","content","filename","fileType","blob","Blob","type","window","navigator","msSaveBlob","URL","createObjectURL","linkElement","document","createElement","download","href","dataset","downloadurl","style","display","body","appendChild","click","removeChild","setTimeout","revokeObjectURL","getQueryStringValue","name","url","location","queryStringStart","indexOf","queryString","substring","length","split","keyValue","decodeURIComponent","declarePolyfills","Array","prototype","includes","console","log","Object","defineProperty","value","element","this","String","repeat","count","Infinity","RangeError","result","i","Helpers","canvasPlotter","PlotterCanvas2D","threadPlotter","threadComputer","needToReset","mainLoop","reset","Parameters","linesOpacity","linesThickness","computeNextSegments","showIndicators","updateIndicators","Page","Canvas","setIndicatorText","plot","debug","drawDebugView","context","requestAnimationFrame","updateBlur","blur","onNewImage","image","showLoader","ThreadComputer","ThreadPlotter","addRedrawObserver","addResetObserver","addBlurChangeObserver","addFileUploadObserver","defaultImage","Image","addEventListener","src","addDownloadObserver","svgPlotter","PlotterSVG","svgString","export","addDownloadInstructionsObserver","text","instructions","main","EShape","EMode","controlId","redrawObservers","triggerRedraw","observer","resetObservers","triggerReset","Tabs","addObserver","Range","addLazyObserver","Checkbox","Observers","canvasResize","push","isInDebug","updateIndicatorsVisibility","shouldBeVisible","isChecked","setIndicatorsVisibility","setIndicatorVisibility","callback","FileControl","addUploadObserver","filesList","FileReader","onload","readAsDataURL","getValues","getValue","raw","Math","pow","updateDownloadInstructionsVisibility","isMonochrome","mode","MONOCHROME","isBlackOnWhite","invertColors","Controls","setVisibility","ECompositingOperation","EColor","supportsAdvancedCompositing","computeRawColor","color","r","g","b","RED","GREEN","BLUE","resetCanvasCompositing","globalCompositeOperation","useAdvancedCompositing","applyCanvasCompositing","opacity","operation","rawRGB","targetOperation","LIGHTEN","ceil","strokeStyle","Demopage","setErrorMessage","DARKEN","drawBrokenLine","points","thickness","lines","from","to","drawLines","PlotterBase","canvas","getCanvas","getContext","alpha","cssPixel","devicePixelRatio","resize","actualWidth","floor","clientWidth","actualHeight","clientHeight","width","height","initialize","infos","fillStyle","backgroundColor","lineJoin","fillRect","finalize","filter","lineWidth","line","beginPath","moveTo","x","y","lineTo","stroke","closePath","drawPoints","diameter","point","arc","PI","fill","BLUR_EFFECT_ID","writer","XMLWriter","hasBlur","addLine","startBlock","endBlock","WIDTH","HEIGHT","strokeColor","toFixed","start","Date","now","indentationLevel","join","prefix","MIN_SAFE_NUMBER","TWO_PI","clamp","min","max","mix","a","randomItem","list","random","hiddenCanvasData","sourceImage","hiddenCanvas","hiddenCanvasContext","drawThread","plotter","nbSegmentsToIgnore","transformation","computeTransformation","size","scaling","hiddenCanvasScale","lineThickness","compositing","thread","iterateOnThreads","peg","transform","lineOpacity","drawPegs","pointSize","pegs","targetContext","drawImage","maxMillisecondsTaken","performance","targetNbSegments","nbLines","nbSegments","lowerNbSegments","resetHiddenCanvas","lineOpacityInternal","iPeg","drawSegmentOnHiddenCanvas","computeError","lastColor","threadToGrow","getThreadToGrow","enableSamplingFor","computeSegment","linethickness","quality","ThreadMonochrome","ThreadRedBlueGreen","computePegs","updateFunction","toString","error","average","meanSquare","variance","totalNbSegments","domainWidth","domainHeight","threadThickness","namedPegs","iP","namedThread","initializeHiddenCanvasLineProperties","theoricalThicknes","lastPeg","nextPeg","startingSegment","computeBestStartingSegment","peg1","peg2","HISTORY_SIZE","prevousPegs","slice","computeBestNextPeg","wantedSize","computeBestSize","imageData","getImageData","adjustCanvasData","data","putImageData","uploadCanvasDataToCPU","nbPixels","nbSamples","errorRed","errorGreen","errorBlue","round","distancetoError","targetSize","Transformation","candidates","bestScore","step","iPegId1","iPegId2","arePegsTooClose","candidateScore","computeSegmentPotential","currentPeg","pegsToAvoid","p1","p2","dX","dY","potential","segmentLength","sqrt","iSample","sample","sampleCanvasData","coords","minX","maxX","minY","maxY","topLeft","sampleCanvasPixel","topRight","bottomLeft","bottomRight","fractX","top","bottom","pixelX","pixelY","index","sampleCanvas","sourceImageSize","maxSize","sizingFactor","domainSize","DEFAULT_CANVAS_SIZE_FOR_PEGS","aspectRatio","pegsShape","shape","pegsCount","RECTANGLE","nbPegsPerWidth","nbPegsPerHeight","iW","iH","absDeltaAngle","abs","angle","halfWidth","halfHeight","distanceBetweenPegs","cosAngle","cos","sinAngle","sin","nbSegmentsDrawn","plotterInfos","displayPegs","lowerNbSegmentsForThread","targetNumber","computeNbSegments","iterateOnThread","fromSegmentNumber","ThreadBase","threadPegs","blackBackground","computeAdjustedValue","rawValue","adjustedValue","threadPegsRed","threadPegsGreen","threadPegsBlue","repartition","computeIdealSegmentsRepartition","red","green","blue","cumulatedRed","cumulatedGreen","cumulatedBlue","totalColor","frequencyRed","frequencyGreen","frequencyBlue","channel","idealRed","idealGreen","idealBlue","gapRed","gapGreen","gapBlue","frameSize","elementSize","scaleToFitWidth","scaleToFitHeight","origin","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","call"],"sourceRoot":""}